section .data
    ; Entrada: 24 bytes
    input db	0x73, 0x38, 0xE7, 0xF7, 0x34, 0x2C, 0x4F, 0x92
    		    db	0x49, 0x55, 0xE5, 0x9F, 0x8E, 0xF2, 0x75, 0x5A 
                db	0xD3, 0xC5, 0x53, 0x65, 0x68, 0x52, 0x78, 0x3F   ; Ejemplo de 24 bytes
    largoSecuenciaA		db	0x18 ; 24d
    output db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    table db 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' ; Tabla Base64

section .text
extern puts                          ; Declarar la función puts
global main

main:
    ; Preparar registros
    mov rsi, input                   ; Puntero a la entrada
    mov rdi, output                  ; Puntero al buffer de salida
    xor rax, rax                     ; Limpiar rax
    xor rdx, rdx                     ; Inicializar el índice de bytes procesados

procesar_secuencia:
    ; ¿Hemos procesado todos los bytes? (24 bytes en total)
    cmp rdx, 0x18                      ; Comparar rdx con el tamaño de la entrada
    jae fin_codificacion             ; Si rdx >= 24, terminamos

    ; Limpiar rax para procesar un nuevo bloque
    xor rax, rax

    ; Leer los 3 bytes en rax
    mov al, byte [rsi]               ; Primer byte
    shl rax, 8                       ; Desplazar a la izquierda
    mov al, byte [rsi+1]             ; Segundo byte
    shl rax, 8                       ; Desplazar a la izquierda
    mov al, byte [rsi+2]             ; Tercer byte

    ; Dividir en 4 grupos de 6 bits
    mov rcx, 4                       ; Necesitamos procesar 4 bloques
    mov rbx, 0x3F                    ; Máscara para extraer 6 bits (0b111111)

generar_bloque:
    ; Desplazar rax y extraer los bits relevantes
    mov r8, rax                      ; Copiar rax a r8
    shr r8, 18                       ; Desplazar 18 bits (primer grupo)
    and r8, rbx                      ; Aplicar la máscara para obtener los 6 bits
    add r8, table                    ; Mapear índice a carácter en la tabla
    mov r9b, byte [r8]               ; Obtener el carácter correspondiente
    mov byte [rdi], r9b              ; Guardar el carácter en el buffer de salida
    inc rdi                          ; Avanzar el puntero de salida
    shl rax, 6                       ; Preparar para el siguiente grupo
    loop generar_bloque              ; Repetir para los 4 bloques

    ; Avanzar en la entrada y el índice de procesamiento
    add rsi, 3                       ; Avanzar 3 bytes en la entrada
    add rdx, 3                       ; Incrementar el índice de bytes procesados
    jmp procesar_secuencia           ; Procesar el siguiente bloque

fin_codificacion:
    ; Agregar terminador null al buffer de salida
    mov byte [rdi], 0

    ; Imprimir la salida usando puts
    mov rdi, output
    call puts

    ; Finalizar el programa
    mov rax, 60                      ; Syscall para exit
    xor rdi, rdi                     ; Código de salida 0
    syscall
